# 小猫更衣 MVP 技术方案

## 1. 项目概述与技术栈选型

### 1.1 项目概述
小猫更衣是一个基于AI的虚拟试穿平台，允许用户上传个人照片和服装图片，通过AI生成真实感强的虚拟试穿效果。项目采用充值VIP制积分会员体系，提供Free、Plus、Pro三种用户等级，通过经济杠杆实现防刷和商业化运营。

### 1.2 核心功能
- **AI虚拟换衣**：集成APIcore AI引擎，实现高质量图像生成
- **充值VIP制积分体系**：2积分/次消费，三级用户权益差异化，积分永不清零
- **用户等级管理**：Free注册、Plus加微信升级、Pro购买积分包升级
- **线下交易系统**：微信红包充值，手动积分发放，有效防刷

### 1.3 技术栈选型

#### 前端技术栈
```
Next.js 14 (App Router) - 全栈框架，支持SSR和API Routes
TypeScript - 类型安全，提升开发效率
Tailwind CSS - 原子化CSS框架，快速样式开发
shadcn/ui - 高质量React组件库
React Hook Form - 表单处理和验证
Zustand/React Context - 状态管理
```

#### 后端技术栈  
```
Next.js API Routes - 服务端API实现
NextAuth.js - 认证系统，支持多种认证方式
Turso SQLite (libSQL) - 边缘数据库，低延迟高性能
Bcrypt - 密码加密
Node-cron - 定时任务调度
```

#### 外部服务集成
```
APIcore AI (gemini-2.5-flash-image) - AI图像生成服务
Cloudflare Pages - 部署平台，全球CDN加速
Cloudflare Workers - 定时任务执行环境
```

### 1.4 技术选型理由

**Next.js 14选择理由**：
- 全栈开发能力，前后端一体化
- App Router提供更好的性能和开发体验
- 内置图像优化，适合图片处理场景
- Vercel/Cloudflare部署友好

**Turso SQLite选择理由**：
- 边缘计算数据库，全球低延迟访问
- SQLite兼容性，开发调试方便
- 内置复制和同步功能
- 成本效益高，适合MVP阶段

**APIcore AI选择理由**：
- 支持图像输入输出，符合换衣场景需求
- OpenAI兼容接口，集成简单
- 提供的API key和示例完整

---

## 2. 系统架构设计

### 2.1 整体架构图
```
┌─────────────────────────────────────────────────────────────┐
│                    Cloudflare CDN                          │
└─────────────────────┬───────────────────────────────────────┘
                      │
┌─────────────────────┴───────────────────────────────────────┐
│                Next.js 14 Application                      │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │
│  │   Frontend      │  │   API Routes    │  │   Auth      │ │
│  │  - React Pages  │  │  - /api/auth/*  │  │ - NextAuth  │ │
│  │  - Components   │  │  - /api/ai/*    │  │ - Sessions  │ │
│  │  - UI Library   │  │  - /api/user/*  │  │ - JWT       │ │
│  └─────────────────┘  └─────────────────┘  └─────────────┘ │
└─────────────────────┬───────────────────────────────────────┘
                      │
      ┌───────────────┼───────────────┐
      │               │               │
      ▼               ▼               ▼
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│   Turso     │ │ APIcore AI  │ │ Cloudflare  │
│  Database   │ │   Service   │ │   Workers   │
│ - Users     │ │ - Image Gen │ │ - Cron Jobs │
│ - Credits   │ │ - Retries   │ │ - Daily     │
│ - History   │ │ - Base64    │ │   Credits   │
└─────────────┘ └─────────────┘ └─────────────┘
```

### 2.2 架构层次说明

#### 2.2.1 表现层 (Presentation Layer)
**职责**：用户界面展示和交互处理
```typescript
// 主要组件结构
src/
├── app/                    # App Router页面
│   ├── page.tsx           # 主页（上传+生成）
│   ├── login/page.tsx     # 登录页
│   ├── profile/page.tsx   # 个人中心
│   └── result/page.tsx    # 结果展示页
├── components/            # 共享组件
│   ├── ui/               # shadcn/ui组件
│   ├── upload/           # 图片上传组件
│   ├── progress/         # 进度条组件
│   └── credits/          # 积分显示组件
└── lib/                  # 工具函数
    ├── auth.ts           # 认证配置
    ├── db.ts             # 数据库连接
    └── utils.ts          # 通用工具
```

#### 2.2.2 业务逻辑层 (Business Logic Layer)
**职责**：核心业务规则实现和数据处理
```typescript
// API Routes结构
src/app/api/
├── auth/                 # NextAuth认证端点
│   └── [...nextauth]/
├── ai/                   # AI相关接口
│   ├── generate/         # 图片生成
│   └── status/           # 生成状态查询
├── user/                 # 用户相关接口  
│   ├── credits/          # 积分管理
│   ├── profile/          # 用户信息
│   └── daily-credits/    # 每日积分领取
└── admin/                # 管理员接口
    └── redeem/           # 兑换码管理
```

#### 2.2.3 数据访问层 (Data Access Layer)
**职责**：数据库操作和外部服务集成
```typescript
// 数据访问模块
src/lib/
├── database/
│   ├── users.ts          # 用户数据操作
│   ├── credits.ts        # 积分系统
│   ├── generations.ts    # 生成历史
│   └── redemption.ts     # 兑换码管理
├── services/
│   ├── ai-service.ts     # AI接口封装
│   ├── auth-service.ts   # 认证服务
│   └── cron-service.ts   # 定时任务
└── types/
    └── database.ts       # 数据类型定义
```

### 2.3 数据流设计

#### 2.3.1 用户注册登录流程
```
User Input → NextAuth.js → Database → JWT Session → Client State
```

#### 2.3.2 AI生成流程
```
Image Upload → Format Validation → Credits Check → AI API Call → 
Result Processing → Credits Deduction → Response to Client
```

#### 2.3.3 每日积分发放流程
```
Cron Trigger → Get All Users → Check Daily Record → 
Award Credits → Log Record → Update User Credits
```

### 2.4 安全架构

#### 2.4.1 认证安全
- JWT token验证所有API请求
- 密码bcrypt加密存储
- Session过期自动清理

#### 2.4.2 数据安全
- 用户图片不持久化存储
- API接口输入验证和过滤
- 数据库查询参数化防注入

#### 2.4.3 业务安全
- 用户级别的并发请求限制
- 积分系统原子性操作
- 每日积分防重复发放机制

---

## 3. 数据库设计详解

### 3.1 Turso SQLite集成方案

#### 3.1.1 连接配置
```typescript
// lib/db.ts
import { createClient } from '@libsql/client';

const dbClient = createClient({
  url: process.env.TURSO_DATABASE_URL!,
  authToken: process.env.TURSO_AUTH_TOKEN!,
});

export { dbClient };
```

#### 3.1.2 环境变量配置
```env
# .env.local
TURSO_DATABASE_URL=libsql://test-xiaogeaibreaker.aws-ap-northeast-1.turso.io
TURSO_AUTH_TOKEN=eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...
```

### 3.2 数据库表结构设计

#### 3.2.1 用户表 (users)
```sql
CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  email TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  user_level TEXT DEFAULT 'free' CHECK (user_level IN ('free', 'plus', 'pro')), -- 充值VIP制等级
  credits INTEGER DEFAULT 6, -- 积分余额，新用户注册赠送6积分
  wechat_upgraded BOOLEAN DEFAULT FALSE, -- 是否通过微信升级Plus
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 索引优化
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_level ON users(user_level);
CREATE INDEX idx_users_wechat ON users(wechat_upgraded);
```

#### 3.2.2 签到记录表 (user_checkins)
```sql
CREATE TABLE user_checkins (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  checkin_type TEXT CHECK (checkin_type IN ('daily', 'weekly')), -- 签到类型
  checkin_period TEXT NOT NULL, -- 签到周期标识：YYYY-MM-DD（日）或 YYYY-W##（周）
  credits_awarded INTEGER DEFAULT 6, -- 发放的积分数
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(user_id, checkin_period), -- 防止同一周期重复签到
  FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
);

-- 索引优化  
CREATE INDEX idx_checkins_user ON user_checkins(user_id, checkin_period DESC);
CREATE INDEX idx_checkins_period ON user_checkins(checkin_period DESC);
```

#### 3.2.3 积分充值记录表 (credit_purchases)
```sql
CREATE TABLE credit_purchases (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  package_name TEXT NOT NULL, -- 积分包名称
  package_price DECIMAL(10,2) NOT NULL, -- 积分包价格
  base_credits INTEGER NOT NULL, -- 基础积分数
  bonus_credits INTEGER DEFAULT 0, -- 赠送积分数
  total_credits INTEGER NOT NULL, -- 总积分数
  payment_method TEXT DEFAULT 'wechat', -- 支付方式
  transaction_status TEXT DEFAULT 'completed', -- 交易状态
  admin_note TEXT, -- 管理员备注
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
);

-- 索引优化
CREATE INDEX idx_purchases_user ON credit_purchases(user_id, created_at DESC);
CREATE INDEX idx_purchases_status ON credit_purchases(transaction_status);
```

#### 3.2.4 生成历史表 (generation_history)
```sql
CREATE TABLE generation_history (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  credits_used INTEGER NOT NULL, -- 使用的积分数（整数化）
  clothing_count INTEGER DEFAULT 1, -- 生成的服装数量
  generation_type TEXT DEFAULT 'single' CHECK (generation_type IN ('single', 'batch')), -- 生成类型
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  error_message TEXT, -- 失败时的错误信息
  processing_time INTEGER, -- 处理时间（秒）
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  completed_at DATETIME, -- 完成时间
  FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
);

-- 索引优化
CREATE INDEX idx_generation_user ON generation_history(user_id, created_at DESC);
CREATE INDEX idx_generation_status ON generation_history(status, created_at);
CREATE INDEX idx_generation_type ON generation_history(generation_type, user_id);
```

#### 3.2.5 用户会话表 (sessions) - NextAuth.js
```sql
-- NextAuth.js自动创建，用于会话管理
CREATE TABLE sessions (
  id TEXT PRIMARY KEY,
  sessionToken TEXT NOT NULL UNIQUE,
  userId INTEGER NOT NULL,
  expires DATETIME NOT NULL,
  FOREIGN KEY (userId) REFERENCES users (id) ON DELETE CASCADE
);

CREATE INDEX idx_sessions_token ON sessions(sessionToken);
CREATE INDEX idx_sessions_expires ON sessions(expires);
```

### 3.3 数据访问层(DAO)设计

#### 3.3.1 用户数据访问
```typescript
// lib/database/users.ts
import { dbClient } from '../db';
import bcrypt from 'bcrypt';

export interface User {
  id: number;
  email: string;
  subscription_type: 'free' | 'plus_monthly' | 'plus_yearly';
  credits: number;
  subscription_expires_at?: Date;
  created_at: Date;
}

export class UserDAO {
  // 创建用户
  static async createUser(email: string, password: string): Promise<User> {
    const passwordHash = await bcrypt.hash(password, 12);
    
    const result = await dbClient.execute({
      sql: `INSERT INTO users (email, password_hash) VALUES (?, ?) RETURNING *`,
      args: [email, passwordHash]
    });
    
    return result.rows[0] as User;
  }
  
  // 验证用户登录
  static async validateUser(email: string, password: string): Promise<User | null> {
    const result = await dbClient.execute({
      sql: `SELECT * FROM users WHERE email = ?`,
      args: [email]
    });
    
    if (result.rows.length === 0) return null;
    
    const user = result.rows[0];
    const isValidPassword = await bcrypt.compare(password, user.password_hash as string);
    
    return isValidPassword ? user as User : null;
  }
  
  // 更新用户积分
  static async updateCredits(userId: number, creditsDelta: number): Promise<void> {
    await dbClient.execute({
      sql: `UPDATE users SET credits = credits + ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
      args: [creditsDelta, userId]
    });
  }
  
  // 获取用户信息
  static async getUserById(userId: number): Promise<User | null> {
    const result = await dbClient.execute({
      sql: `SELECT * FROM users WHERE id = ?`,
      args: [userId]
    });
    
    return result.rows.length > 0 ? result.rows[0] as User : null;
  }
  
  // 更新订阅状态
  static async updateSubscription(
    userId: number, 
    subscriptionType: string, 
    expiresAt: Date
  ): Promise<void> {
    await dbClient.execute({
      sql: `UPDATE users SET 
              subscription_type = ?, 
              subscription_expires_at = ?,
              updated_at = CURRENT_TIMESTAMP 
            WHERE id = ?`,
      args: [subscriptionType, expiresAt.toISOString(), userId]
    });
  }
  
  // 获取所有活跃用户（用于每日积分发放）
  static async getAllActiveUsers(): Promise<User[]> {
    const result = await dbClient.execute({
      sql: `SELECT * FROM users WHERE created_at >= datetime('now', '-30 days')`
    });
    
    return result.rows as User[];
  }
}
```

#### 3.3.2 积分系统数据访问
```typescript
// lib/database/credits.ts
import { dbClient } from '../db';

export class CreditsDAO {
  // 检查今日是否已发放积分
  static async hasDailyCreditsAwarded(userId: number, date: string): Promise<boolean> {
    const result = await dbClient.execute({
      sql: `SELECT id FROM daily_credits_log WHERE user_id = ? AND award_date = ?`,
      args: [userId, date]
    });
    
    return result.rows.length > 0;
  }
  
  // 发放每日积分
  static async awardDailyCredits(userId: number, credits: number, date: string): Promise<void> {
    await dbClient.batch([
      {
        sql: `UPDATE users SET credits = credits + ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`,
        args: [credits, userId]
      },
      {
        sql: `INSERT INTO daily_credits_log (user_id, credits_awarded, award_date) VALUES (?, ?, ?)`,
        args: [userId, credits, date]
      }
    ]);
  }
  
  // 扣除积分（生成图片时）
  static async deductCredits(userId: number, creditsUsed: number): Promise<boolean> {
    const result = await dbClient.execute({
      sql: `UPDATE users SET credits = credits - ?, updated_at = CURRENT_TIMESTAMP 
            WHERE id = ? AND credits >= ?`,
      args: [creditsUsed, userId, creditsUsed]
    });
    
    return result.rowsAffected > 0;
  }
  
  // 获取用户积分余额
  static async getUserCredits(userId: number): Promise<number> {
    const result = await dbClient.execute({
      sql: `SELECT credits FROM users WHERE id = ?`,
      args: [userId]
    });
    
    return result.rows.length > 0 ? result.rows[0].credits as number : 0;
  }
}
```

### 3.4 数据库优化策略

#### 3.4.1 查询优化
- 为常用查询字段添加索引
- 使用复合索引优化多字段查询
- 分页查询避免全表扫描

#### 3.4.2 事务管理
- 积分相关操作使用事务保证一致性
- 批量操作使用batch接口提高性能
- 关键操作添加重试机制

#### 3.4.3 数据维护
- 定期清理过期会话数据
- 归档历史生成记录
- 监控数据库性能指标

---

## 4. 核心功能模块设计

### 4.1 认证系统模块

#### 4.1.1 NextAuth.js配置
```typescript
// lib/auth.ts
import NextAuth from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import { UserDAO } from './database/users';

export const authOptions = {
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' }
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        const user = await UserDAO.validateUser(
          credentials.email, 
          credentials.password
        );

        if (user) {
          return {
            id: user.id.toString(),
            email: user.email,
            subscription_type: user.subscription_type,
            credits: user.credits
          };
        }

        return null;
      }
    })
  ],
  session: {
    strategy: 'jwt' as const,
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  jwt: {
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.subscription_type = user.subscription_type;
        token.credits = user.credits;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.sub!;
        session.user.subscription_type = token.subscription_type as string;
        session.user.credits = token.credits as number;
      }
      return session;
    }
  },
  pages: {
    signIn: '/login',
    signUp: '/register',
  }
};

export default NextAuth(authOptions);
```

#### 4.1.2 注册登录页面组件
```typescript
// app/register/page.tsx
'use client';
import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

export default function RegisterPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });

      if (response.ok) {
        router.push('/login?message=注册成功，请登录');
      } else {
        const error = await response.json();
        alert(error.message || '注册失败');
      }
    } catch (error) {
      alert('注册失败，请重试');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle>用户注册</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            <Input
              type="email"
              placeholder="邮箱地址"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
            <Input
              type="password"
              placeholder="密码"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              minLength={6}
            />
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? '注册中...' : '注册'}
            </Button>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
```

### 4.2 图片上传模块

#### 4.2.1 多文件上传组件
```typescript
// components/upload/ImageUpload.tsx
'use client';
import { useState, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { X, Upload } from 'lucide-react';
import Image from 'next/image';

interface ImageUploadProps {
  onImagesChange: (images: File[]) => void;
  maxFiles: number;
  acceptedFormats: string[];
  title: string;
}

export default function ImageUpload({
  onImagesChange,
  maxFiles,
  acceptedFormats,
  title
}: ImageUploadProps) {
  const [uploadedImages, setUploadedImages] = useState<File[]>([]);
  const [previews, setPreviews] = useState<string[]>([]);

  const onDrop = useCallback((acceptedFiles: File[]) => {
    const newFiles = acceptedFiles.slice(0, maxFiles - uploadedImages.length);
    const updatedFiles = [...uploadedImages, ...newFiles];
    
    setUploadedImages(updatedFiles);
    onImagesChange(updatedFiles);

    // 生成预览图
    const newPreviews = newFiles.map(file => URL.createObjectURL(file));
    setPreviews(prev => [...prev, ...newPreviews]);
  }, [uploadedImages, maxFiles, onImagesChange]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'image/*': acceptedFormats
    },
    maxFiles: maxFiles - uploadedImages.length,
    disabled: uploadedImages.length >= maxFiles
  });

  const removeImage = (index: number) => {
    const updatedFiles = uploadedImages.filter((_, i) => i !== index);
    const updatedPreviews = previews.filter((_, i) => i !== index);
    
    setUploadedImages(updatedFiles);
    setPreviews(updatedPreviews);
    onImagesChange(updatedFiles);
    
    // 清理blob URL
    URL.revokeObjectURL(previews[index]);
  };

  return (
    <Card>
      <CardContent className="p-6">
        <h3 className="text-lg font-medium mb-4">{title}</h3>
        
        {/* 上传区域 */}
        {uploadedImages.length < maxFiles && (
          <div
            {...getRootProps()}
            className={`border-2 border-dashed rounded-lg p-6 text-center cursor-pointer transition-colors
              ${isDragActive 
                ? 'border-blue-500 bg-blue-50' 
                : 'border-gray-300 hover:border-gray-400'
              }`}
          >
            <input {...getInputProps()} />
            <Upload className="mx-auto h-12 w-12 text-gray-400 mb-4" />
            <p className="text-gray-600">
              {isDragActive
                ? '拖放图片到这里'
                : `点击上传或拖放图片 (最多${maxFiles}张)`
              }
            </p>
            <p className="text-sm text-gray-400 mt-2">
              支持 JPG, PNG, WebP 格式
            </p>
          </div>
        )}

        {/* 预览区域 */}
        {uploadedImages.length > 0 && (
          <div className="mt-4">
            <h4 className="text-sm font-medium mb-2">
              已上传 {uploadedImages.length}/{maxFiles} 张图片
            </h4>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
              {previews.map((preview, index) => (
                <div key={index} className="relative group">
                  <div className="aspect-square relative overflow-hidden rounded-lg border">
                    <Image
                      src={preview}
                      alt={`预览 ${index + 1}`}
                      fill
                      className="object-cover"
                    />
                  </div>
                  <Button
                    size="sm"
                    variant="destructive"
                    className="absolute -top-2 -right-2 h-6 w-6 p-0 opacity-0 group-hover:opacity-100 transition-opacity"
                    onClick={() => removeImage(index)}
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              ))}
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
```

### 4.3 进度条组件

#### 4.3.1 状态文字进度条
```typescript
// components/progress/GenerationProgress.tsx
'use client';
import { Card, CardContent } from '@/components/ui/card';
import { Loader2 } from 'lucide-react';

interface GenerationProgressProps {
  status: 'idle' | 'uploading' | 'analyzing' | 'generating' | 'completed' | 'failed';
  message?: string;
}

const statusMessages = {
  idle: '准备开始生成',
  uploading: '正在上传图片...',
  analyzing: '正在分析照片...',
  generating: '正在生成图片...',
  completed: '生成完成，请下载',
  failed: '生成失败'
};

const statusColors = {
  idle: 'text-gray-500',
  uploading: 'text-blue-500',
  analyzing: 'text-yellow-500', 
  generating: 'text-purple-500',
  completed: 'text-green-500',
  failed: 'text-red-500'
};

export default function GenerationProgress({ 
  status, 
  message 
}: GenerationProgressProps) {
  const isProcessing = ['uploading', 'analyzing', 'generating'].includes(status);
  
  return (
    <Card>
      <CardContent className="p-6 text-center">
        <div className="flex flex-col items-center space-y-4">
          {isProcessing && (
            <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
          )}
          
          <div className="space-y-2">
            <p className={`text-lg font-medium ${statusColors[status]}`}>
              {message || statusMessages[status]}
            </p>
            
            {status === 'failed' && (
              <p className="text-sm text-gray-600">
                积分已退还，请重新尝试
              </p>
            )}
          </div>
          
          {/* 进度指示器 */}
          <div className="w-full max-w-xs">
            <div className="flex justify-between text-xs text-gray-500 mb-1">
              <span className={status === 'uploading' ? 'text-blue-500 font-medium' : ''}>
                上传
              </span>
              <span className={status === 'analyzing' ? 'text-yellow-500 font-medium' : ''}>
                分析
              </span>
              <span className={status === 'generating' ? 'text-purple-500 font-medium' : ''}>
                生成
              </span>
              <span className={status === 'completed' ? 'text-green-500 font-medium' : ''}>
                完成
              </span>
            </div>
            
            <div className="w-full bg-gray-200 rounded-full h-2">
              <div 
                className={`h-2 rounded-full transition-all duration-500 ${
                  status === 'completed' ? 'bg-green-500' : 
                  status === 'failed' ? 'bg-red-500' : 'bg-blue-500'
                }`}
                style={{
                  width: status === 'idle' ? '0%' :
                         status === 'uploading' ? '25%' :
                         status === 'analyzing' ? '50%' :
                         status === 'generating' ? '75%' :
                         status === 'completed' ? '100%' :
                         status === 'failed' ? '100%' : '0%'
                }}
              />
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```

### 4.4 积分管理组件

#### 4.4.1 积分显示组件
```typescript
// components/credits/CreditsDisplay.tsx
'use client';
import { useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Coins, Gift } from 'lucide-react';

interface CreditsDisplayProps {
  onCreditsChange?: (credits: number) => void;
}

export default function CreditsDisplay({ onCreditsChange }: CreditsDisplayProps) {
  const { data: session, update } = useSession();
  const [credits, setCredits] = useState(session?.user?.credits || 0);
  const [canClaimDaily, setCanClaimDaily] = useState(false);
  const [isClaiming, setIsClaiming] = useState(false);

  useEffect(() => {
    checkDailyCredits();
  }, []);

  const checkDailyCredits = async () => {
    try {
      const response = await fetch('/api/user/daily-credits/check');
      const data = await response.json();
      setCanClaimDaily(data.canClaim);
    } catch (error) {
      console.error('检查每日积分失败:', error);
    }
  };

  const claimDailyCredits = async () => {
    setIsClaiming(true);
    try {
      const response = await fetch('/api/user/daily-credits/claim', {
        method: 'POST'
      });
      
      if (response.ok) {
        const data = await response.json();
        const newCredits = credits + 10;
        setCredits(newCredits);
        setCanClaimDaily(false);
        onCreditsChange?.(newCredits);
        
        // 更新session
        await update({ credits: newCredits });
      }
    } catch (error) {
      console.error('领取每日积分失败:', error);
    } finally {
      setIsClaiming(false);
    }
  };

  return (
    <Card>
      <CardContent className="p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-2">
            <Coins className="h-5 w-5 text-yellow-500" />
            <span className="font-medium">积分余额</span>
            <span className="text-lg font-bold text-blue-600">{credits}</span>
          </div>
          
          {canClaimDaily && (
            <Button
              size="sm"
              onClick={claimDailyCredits}
              disabled={isClaiming}
              className="bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600"
            >
              <Gift className="h-4 w-4 mr-1" />
              {isClaiming ? '领取中...' : '领取今日积分'}
            </Button>
          )}
        </div>
        
        <p className="text-xs text-gray-500 mt-1">
          每次生成消耗1.5积分，每日可免费领取10积分
        </p>
      </CardContent>
    </Card>
  );
}
```

---

## 5. AI换衣实现方案

### 5.1 APIcore AI集成

#### 5.1.1 AI服务封装
```typescript
// lib/services/ai-service.ts
interface AIGenerationRequest {
  userImage: string; // base64编码
  clothingImages: string[]; // base64编码数组
}

interface AIGenerationResponse {
  success: boolean;
  images?: string[]; // 生成的图片URLs
  error?: string;
}

export class AIService {
  private static readonly API_URL = 'https://kg-api.cloud/v1/chat/completions';
  private static readonly API_KEY = process.env.APICORE_AI_KEY!;
  private static readonly MODEL = 'gemini-2.5-flash-image';

  // 生成换衣图片
  static async generateTryOn({
    userImage,
    clothingImages
  }: AIGenerationRequest): Promise<AIGenerationResponse> {
    const prompt = this.buildTryOnPrompt(clothingImages.length);
    
    try {
      const response = await fetch(this.API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.API_KEY}`
        },
        body: JSON.stringify({
          model: this.MODEL,
          messages: [
            {
              role: 'user',
              content: [
                { type: 'text', text: prompt },
                { 
                  type: 'image_url', 
                  image_url: { url: `data:image/jpeg;base64,${userImage}` }
                },
                ...clothingImages.map(img => ({
                  type: 'image_url',
                  image_url: { url: `data:image/jpeg;base64,${img}` }
                }))
              ]
            }
          ],
          max_tokens: 500
        })
      });

      if (!response.ok) {
        throw new Error(`AI API request failed: ${response.status}`);
      }

      const data = await response.json();
      const imageUrls = this.extractImageUrls(data.choices[0].message.content);

      return {
        success: true,
        images: imageUrls
      };
    } catch (error) {
      console.error('AI generation failed:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  // 构建专业的换衣prompt
  private static buildTryOnPrompt(clothingCount: number): string {
    const basePrompt = `请将用户照片中的人物换上新的服装，要求：
1. 保持人物的面部特征、发型、体型和姿态完全不变
2. 服装要自然贴合人物身形，考虑光影和褶皱效果  
3. 保持原照片的背景、光线和整体氛围
4. 生成真实感强的穿着效果，避免违和感
5. 确保服装的材质、颜色和细节准确还原
6. 如果是连衣裙等全身服装，要合理调整下半身`;

    const multiplePrompt = clothingCount > 1 ? 
      `\n7. 请为这一个人物分别生成穿着每件不同服装的效果图，每张图保持人物一致性` : "";
      
    return basePrompt + multiplePrompt + `\n\n请直接生成换衣后的图片，不要添加其他解释文字。`;
  }

  // 从AI响应中提取图片URLs
  private static extractImageUrls(content: string): string[] {
    const imageUrls: string[] = [];
    
    // 匹配markdown格式的图片链接: ![image](url)
    const markdownImageRegex = /!\[.*?\]\((https?:\/\/[^\)]+)\)/g;
    let match;
    
    while ((match = markdownImageRegex.exec(content)) !== null) {
      imageUrls.push(match[1]);
    }
    
    // 如果没有找到markdown格式，尝试匹配普通URL
    if (imageUrls.length === 0) {
      const urlRegex = /(https?:\/\/[^\s]+\.(?:png|jpg|jpeg|gif|webp))/gi;
      const matches = content.match(urlRegex);
      if (matches) {
        imageUrls.push(...matches);
      }
    }
    
    return imageUrls;
  }

  // 图片格式转换：File转base64
  static async fileToBase64(file: File): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result as string;
        // 移除data URL前缀，只保留base64数据
        const base64Data = base64.split(',')[1];
        resolve(base64Data);
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  // 图片压缩处理
  static async compressImage(file: File, maxWidth = 1024, quality = 0.8): Promise<File> {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d')!;
      const img = new Image();
      
      img.onload = () => {
        // 计算压缩后尺寸
        const ratio = Math.min(maxWidth / img.width, maxWidth / img.height);
        canvas.width = img.width * ratio;
        canvas.height = img.height * ratio;
        
        // 绘制压缩后的图片
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        
        canvas.toBlob((blob) => {
          const compressedFile = new File([blob!], file.name, {
            type: file.type,
            lastModified: Date.now()
          });
          resolve(compressedFile);
        }, file.type, quality);
      };
      
      img.src = URL.createObjectURL(file);
    });
  }
}
```

### 5.2 重试机制实现

#### 5.2.1 重试逻辑封装
```typescript
// lib/services/retry-service.ts
interface RetryOptions {
  maxRetries: number;
  baseDelay: number;
  maxDelay: number;
}

export class RetryService {
  static async withRetry<T>(
    operation: () => Promise<T>,
    options: RetryOptions = {
      maxRetries: 2,
      baseDelay: 0, // 立即重试
      maxDelay: 0
    }
  ): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 0; attempt <= options.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        
        // 最后一次尝试失败，不再重试
        if (attempt === options.maxRetries) {
          break;
        }
        
        // 计算延迟时间（指数退避）
        const delay = Math.min(
          options.baseDelay * Math.pow(2, attempt),
          options.maxDelay
        );
        
        if (delay > 0) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
        
        console.warn(`Retry attempt ${attempt + 1}/${options.maxRetries} failed:`, error);
      }
    }
    
    throw lastError!;
  }
}
```

### 5.3 生成API端点实现

#### 5.3.1 主要生成接口
```typescript
// app/api/ai/generate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { AIService } from '@/lib/services/ai-service';
import { RetryService } from '@/lib/services/retry-service';
import { UserDAO } from '@/lib/database/users';
import { CreditsDAO } from '@/lib/database/credits';

export async function POST(request: NextRequest) {
  try {
    // 验证用户身份
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: '未授权访问' }, { status: 401 });
    }

    const userId = parseInt(session.user.id);
    const body = await request.json();
    const { userImage, clothingImages } = body;

    // 验证输入参数
    if (!userImage || !clothingImages || !Array.isArray(clothingImages)) {
      return NextResponse.json({ error: '参数错误' }, { status: 400 });
    }

    // 检查用户权限
    const user = await UserDAO.getUserById(userId);
    if (!user) {
      return NextResponse.json({ error: '用户不存在' }, { status: 404 });
    }

    // 权限检查：Free用户限制
    if (user.subscription_type === 'free' && clothingImages.length > 1) {
      return NextResponse.json({ 
        error: 'Free用户只能一次生成一件衣服，请升级到Plus会员' 
      }, { status: 403 });
    }

    // Plus用户数量限制
    if (clothingImages.length > 10) {
      return NextResponse.json({ 
        error: '最多支持10件衣服同时生成' 
      }, { status: 400 });
    }

    // 计算所需积分
    const requiredCredits = clothingImages.length * 1.5;
    if (user.credits < requiredCredits) {
      return NextResponse.json({ 
        error: `积分不足，需要${requiredCredits}积分，当前余额${user.credits}积分` 
      }, { status: 402 });
    }

    // 记录生成开始
    const generationId = Date.now(); // 简单的ID生成
    
    try {
      // 使用重试机制调用AI服务
      const result = await RetryService.withRetry(
        () => AIService.generateTryOn({
          userImage,
          clothingImages
        })
      );

      if (!result.success) {
        throw new Error(result.error || 'AI生成失败');
      }

      // 成功后扣除积分
      const deductSuccess = await CreditsDAO.deductCredits(userId, requiredCredits);
      if (!deductSuccess) {
        // 这种情况理论上不应该发生，因为前面已经检查过积分
        throw new Error('积分扣除失败');
      }

      // 记录成功的生成历史
      // 这里可以添加生成历史记录逻辑

      return NextResponse.json({
        success: true,
        images: result.images,
        creditsUsed: requiredCredits,
        remainingCredits: user.credits - requiredCredits
      });

    } catch (error) {
      console.error('Generation failed after retries:', error);
      
      // 失败时不扣积分，记录失败历史
      // 这里可以添加失败记录逻辑
      
      return NextResponse.json({
        success: false,
        error: '生成失败，积分已退还',
        message: error instanceof Error ? error.message : '未知错误'
      }, { status: 500 });
    }

  } catch (error) {
    console.error('API error:', error);
    return NextResponse.json(
      { error: '服务器内部错误' },
      { status: 500 }
    );
  }
}
```

### 5.4 任务队列管理

#### 5.4.1 简单的内存队列实现
```typescript
// lib/services/task-queue.ts
interface GenerationTask {
  id: string;
  userId: number;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  createdAt: Date;
  completedAt?: Date;
  result?: any;
  error?: string;
}

class TaskQueue {
  private static instance: TaskQueue;
  private tasks = new Map<string, GenerationTask>();
  private userTasks = new Map<number, string>(); // userId -> taskId
  
  static getInstance(): TaskQueue {
    if (!TaskQueue.instance) {
      TaskQueue.instance = new TaskQueue();
    }
    return TaskQueue.instance;
  }
  
  // 检查用户是否有正在进行的任务
  hasActiveTask(userId: number): boolean {
    const taskId = this.userTasks.get(userId);
    if (!taskId) return false;
    
    const task = this.tasks.get(taskId);
    return task?.status === 'pending' || task?.status === 'processing';
  }
  
  // 创建新任务
  createTask(userId: number): string {
    const taskId = `task_${userId}_${Date.now()}`;
    const task: GenerationTask = {
      id: taskId,
      userId,
      status: 'pending',
      createdAt: new Date()
    };
    
    this.tasks.set(taskId, task);
    this.userTasks.set(userId, taskId);
    
    return taskId;
  }
  
  // 更新任务状态
  updateTask(taskId: string, status: GenerationTask['status'], result?: any, error?: string): void {
    const task = this.tasks.get(taskId);
    if (task) {
      task.status = status;
      if (status === 'completed' || status === 'failed') {
        task.completedAt = new Date();
        // 清理用户任务映射
        this.userTasks.delete(task.userId);
      }
      if (result) task.result = result;
      if (error) task.error = error;
    }
  }
  
  // 获取任务状态
  getTask(taskId: string): GenerationTask | undefined {
    return this.tasks.get(taskId);
  }
  
  // 清理过期任务（1小时后自动清理）
  cleanup(): void {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    
    for (const [taskId, task] of this.tasks.entries()) {
      if (task.createdAt < oneHourAgo) {
        this.tasks.delete(taskId);
        if (this.userTasks.get(task.userId) === taskId) {
          this.userTasks.delete(task.userId);
        }
      }
    }
  }
}

export default TaskQueue;
```

### 5.5 前端生成流程整合

#### 5.5.1 主生成页面
```typescript
// app/page.tsx
'use client';
import { useState } from 'react';
import { useSession } from 'next-auth/react';
import ImageUpload from '@/components/upload/ImageUpload';
import GenerationProgress from '@/components/progress/GenerationProgress';
import CreditsDisplay from '@/components/credits/CreditsDisplay';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

export default function HomePage() {
  const { data: session } = useSession();
  const [userImage, setUserImage] = useState<File[]>([]);
  const [clothingImages, setClothingImages] = useState<File[]>([]);
  const [generationStatus, setGenerationStatus] = useState<'idle' | 'uploading' | 'analyzing' | 'generating' | 'completed' | 'failed'>('idle');
  const [resultImages, setResultImages] = useState<string[]>([]);
  const [isGenerating, setIsGenerating] = useState(false);

  const maxClothingFiles = session?.user?.subscription_type === 'free' ? 1 : 10;

  const handleGenerate = async () => {
    if (!userImage.length || !clothingImages.length) {
      alert('请上传用户照片和服装图片');
      return;
    }

    setIsGenerating(true);
    setGenerationStatus('uploading');

    try {
      // 转换图片为base64
      setGenerationStatus('analyzing');
      const userImageBase64 = await AIService.fileToBase64(userImage[0]);
      const clothingImagesBase64 = await Promise.all(
        clothingImages.map(file => AIService.fileToBase64(file))
      );

      // 调用生成接口
      setGenerationStatus('generating');
      const response = await fetch('/api/ai/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userImage: userImageBase64,
          clothingImages: clothingImagesBase64
        })
      });

      const result = await response.json();

      if (result.success) {
        setResultImages(result.images);
        setGenerationStatus('completed');
      } else {
        setGenerationStatus('failed');
        alert(result.error || '生成失败');
      }
    } catch (error) {
      console.error('Generation error:', error);
      setGenerationStatus('failed');
      alert('生成失败，请重试');
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <div className="container mx-auto p-4 max-w-4xl">
      <h1 className="text-3xl font-bold text-center mb-8">小猫更衣 - AI虚拟试穿</h1>
      
      {/* 积分显示 */}
      <CreditsDisplay />
      
      <div className="grid md:grid-cols-2 gap-6 mt-6">
        {/* 用户照片上传 */}
        <ImageUpload
          onImagesChange={setUserImage}
          maxFiles={1}
          acceptedFormats={['.jpg', '.jpeg', '.png', '.webp']}
          title="上传您的照片"
        />
        
        {/* 服装图片上传 */}
        <ImageUpload
          onImagesChange={setClothingImages}
          maxFiles={maxClothingFiles}
          acceptedFormats={['.jpg', '.jpeg', '.png', '.webp']}
          title={`上传服装图片 (最多${maxClothingFiles}件)`}
        />
      </div>
      
      {/* 生成按钮 */}
      <div className="mt-6 text-center">
        <Button
          onClick={handleGenerate}
          disabled={isGenerating || !userImage.length || !clothingImages.length}
          size="lg"
          className="px-8"
        >
          {isGenerating ? '生成中...' : '开始生成'}
        </Button>
      </div>
      
      {/* 进度条 */}
      {generationStatus !== 'idle' && (
        <div className="mt-6">
          <GenerationProgress status={generationStatus} />
        </div>
      )}
      
      {/* 结果展示 */}
      {resultImages.length > 0 && (
        <Card className="mt-6">
          <CardHeader>
            <CardTitle>生成结果</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid md:grid-cols-2 gap-4">
              {resultImages.map((imageUrl, index) => (
                <div key={index} className="space-y-2">
                  <img
                    src={imageUrl}
                    alt={`生成结果 ${index + 1}`}
                    className="w-full h-auto rounded-lg border"
                  />
                  <Button
                    onClick={() => window.open(imageUrl, '_blank')}
                    className="w-full"
                  >
                    下载图片 {index + 1}
                  </Button>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
```

---

## 6. 积分会员体系实现

### 6.1 每日积分发放系统

#### 6.1.1 定时任务实现
```typescript
// lib/services/cron-service.ts
import { CreditsDAO } from '@/lib/database/credits';
import { UserDAO } from '@/lib/database/users';

export class CronService {
  // 每日积分发放主函数
  static async dailyCreditsJob(): Promise<void> {
    console.log('开始每日积分发放任务');
    const today = new Date().toISOString().split('T')[0];
    
    try {
      const users = await UserDAO.getAllActiveUsers();
      let successCount = 0;
      let failureCount = 0;

      for (const user of users) {
        try {
          const hasAwarded = await CreditsDAO.hasDailyCreditsAwarded(user.id, today);
          
          if (!hasAwarded) {
            await CreditsDAO.awardDailyCredits(user.id, 10, today);
            successCount++;
          }
        } catch (error) {
          console.error(`用户 ${user.id} 积分发放失败:`, error);
          failureCount++;
        }
      }

      console.log(`每日积分发放完成: 成功 ${successCount}, 失败 ${failureCount}`);
    } catch (error) {
      console.error('每日积分发放任务失败:', error);
    }
  }
}
```

### 6.2 兑换码系统

#### 6.2.1 兑换码使用接口
```typescript
// app/api/user/redeem/route.ts
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    const { code } = await request.json();
    const userId = parseInt(session.user.id);

    // 验证和使用兑换码逻辑
    const redemptionCode = await RedemptionDAO.getValidCode(code);
    if (!redemptionCode || redemptionCode.used_by_user_id) {
      return NextResponse.json({ error: '兑换码无效或已使用' }, { status: 400 });
    }

    // 发放积分和订阅权益
    await RedemptionDAO.useCode(code, userId);
    if (redemptionCode.credits > 0) {
      await UserDAO.updateCredits(userId, redemptionCode.credits);
    }

    return NextResponse.json({ success: true, message: '兑换成功' });
  } catch (error) {
    return NextResponse.json({ error: '兑换失败' }, { status: 500 });
  }
}
```

---

## 7. 部署与开发计划

### 7.1 Cloudflare部署方案

**环境配置**:
- Cloudflare Pages自动部署
- 环境变量安全管理
- 定时任务Workers配置
- 数据库边缘访问优化

### 7.2 开发里程碑

**阶段1 (2-3天)**: 基础框架搭建
**阶段2 (2天)**: 用户系统和积分体系
**阶段3 (3-4天)**: AI换衣核心功能
**阶段4 (2天)**: 用户体验优化
**阶段5 (1-2天)**: 部署测试

### 7.3 预期成果

- 完整的AI虚拟试穿Web应用
- 积分会员体系和兑换码系统
- 移动端响应式界面
- 生产环境稳定部署
- MVP功能完整验收
