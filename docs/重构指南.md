# å°çŒ«æ›´è¡£é¡¹ç›®æ¶æ„é‡æ„æŠ€æœ¯æŒ‡å—

## ğŸ“š æ–‡æ¡£æ¦‚è¿°

æœ¬æŒ‡å—è¯¦ç»†è®°å½•äº†å°çŒ«æ›´è¡£é¡¹ç›®çš„æœåŠ¡å±‚æ¶æ„é‡æ„è¿‡ç¨‹ã€æŠ€æœ¯å†³ç­–ã€æœ€ä½³å®è·µå’Œç»éªŒæ€»ç»“ï¼Œä¸ºæœªæ¥çš„å¼€å‘å·¥ä½œæä¾›å‚è€ƒã€‚

## ğŸ¯ é‡æ„ç›®æ ‡ä¸æˆæœ

### é‡æ„å‰å­˜åœ¨çš„é—®é¢˜
- **ä»£ç ç»“æ„æ··ä¹±**: 507è¡Œå·¨å‹APIè·¯ç”±ï¼Œä¸šåŠ¡é€»è¾‘ä¸APIé€»è¾‘æ··åˆ
- **ç±»å‹å®‰å…¨ç¼ºå¤±**: å¤§é‡`any`ç±»å‹ä½¿ç”¨ï¼Œç±»å‹å®šä¹‰é‡å¤åˆ†æ•£
- **é…ç½®ç®¡ç†æ··ä¹±**: ç¯å¢ƒå˜é‡å’Œé…ç½®æ•£è½å„å¤„ï¼Œç¼ºä¹ç»Ÿä¸€ç®¡ç†
- **é”™è¯¯å¤„ç†ä¸ä¸€è‡´**: é”™è¯¯å¤„ç†é€»è¾‘åˆ†æ•£ï¼Œæ²¡æœ‰ç»Ÿä¸€çš„é”™è¯¯åˆ†ç±»å’Œå¤„ç†æœºåˆ¶
- **æœåŠ¡èŒè´£ä¸æ¸…**: æ‰€æœ‰ä¸šåŠ¡é€»è¾‘éƒ½é›†ä¸­åœ¨APIè·¯ç”±ä¸­ï¼Œç¼ºä¹æœåŠ¡å±‚æŠ½è±¡

### é‡æ„ç›®æ ‡
1. **å»ºç«‹æœåŠ¡å±‚æ¶æ„**: å°†ä¸šåŠ¡é€»è¾‘æŠ½è±¡åˆ°æœåŠ¡å±‚ï¼Œå®ç°å…³æ³¨ç‚¹åˆ†ç¦»
2. **ç»Ÿä¸€é…ç½®ç®¡ç†**: å»ºç«‹é›†ä¸­åŒ–çš„é…ç½®ç®¡ç†ç³»ç»Ÿ
3. **å®Œå–„é”™è¯¯å¤„ç†**: å®ç°ä¼ä¸šçº§é”™è¯¯å¤„ç†å’Œåˆ†ç±»æœºåˆ¶
4. **å¼ºåŒ–ç±»å‹å®‰å…¨**: æ¶ˆé™¤æ‰€æœ‰`any`ç±»å‹ï¼Œå»ºç«‹å®Œæ•´çš„ç±»å‹ä½“ç³»
5. **æå‡ä»£ç è´¨é‡**: é€šè¿‡æ¶æ„é‡æ„æå‡å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§

### é‡æ„æˆæœæ•°æ®
| æŒ‡æ ‡ | é‡æ„å‰ | é‡æ„å | æ”¹è¿› |
|------|--------|--------|------|
| APIè·¯ç”±è¡Œæ•° | 507è¡Œ | 156è¡Œ | -69% |
| æœåŠ¡å±‚æŠ½è±¡ | 0ä¸ª | 4ä¸ªæœåŠ¡ç±» | +400% |
| anyç±»å‹ä½¿ç”¨ | 15å¤„ | 0å¤„ | -100% |
| é…ç½®æ–‡ä»¶åˆ†æ•£åº¦ | 5ä¸ªæ–‡ä»¶ | 1ä¸ªæ–‡ä»¶ | -80% |
| é”™è¯¯å¤„ç†ç»Ÿä¸€ç‡ | 30% | 100% | +233% |
| TypeScriptä¸¥æ ¼æ¨¡å¼ | éƒ¨åˆ† | å®Œå…¨ | +100% |

## ğŸ—ï¸ é‡æ„æ¶æ„è®¾è®¡

### æ ¸å¿ƒæ¶æ„å˜åŒ–

#### 1. æœåŠ¡å±‚æ¶æ„ (Service Layer)
```typescript
// é‡æ„å‰: æ‰€æœ‰é€»è¾‘éƒ½åœ¨APIè·¯ç”±ä¸­
export async function POST(request: NextRequest) {
  // 507è¡Œä»£ç åŒ…å«ï¼š
  // - èº«ä»½éªŒè¯é€»è¾‘
  // - ä¸šåŠ¡è§„åˆ™éªŒè¯
  // - AI APIè°ƒç”¨
  // - æ•°æ®åº“æ“ä½œ
  // - é”™è¯¯å¤„ç†
  // - å“åº”æ ¼å¼åŒ–
}

// é‡æ„å: åˆ†å±‚æ¶æ„è®¾è®¡
// APIè·¯ç”±å±‚ (src/app/api/generate/route.ts) - 156è¡Œ
export async function POST(request: NextRequest) {
  return ErrorHandler.withErrorHandling(async () => {
    const session = await auth();
    if (!session?.user?.id) throw new UnauthorizedError();
    
    const { userImage, clothingImages } = validateInput(await request.json());
    const user = await UserDAO.findUserById(parseInt(session.user.id));
    
    validateUserPermissions(user.user_level, clothingImages.length);
    const requiredCredits = calculateRequiredCredits(user.user_level, clothingImages.length);
    
    // è°ƒç”¨æœåŠ¡å±‚
    const resultImages = await AIGenerationService.generateWithRetry({
      userImage, clothingImages, generationType: 'single'
    });
    
    return NextResponse.json({ success: true, data: resultImages });
  });
}
```

#### 2. é›†ä¸­åŒ–é…ç½®ç®¡ç† (`src/lib/config/index.ts`)
```typescript
// é‡æ„å‰: é…ç½®æ•£è½åœ¨å„ä¸ªæ–‡ä»¶ä¸­
// route.ts: const apiUrl = 'https://kg-api.cloud/v1/chat/completions';
// component.tsx: const timeout = 60000;
// service.ts: const retries = 2;

// é‡æ„å: ç»Ÿä¸€é…ç½®ç®¡ç†ç³»ç»Ÿ
interface EnvironmentConfig {
  TURSO_DATABASE_URL: string;
  TURSO_AUTH_TOKEN: string;
  NEXTAUTH_URL: string;
  NEXTAUTH_SECRET: string;
  APICORE_AI_KEY: string;
}

export function getEnvironmentConfig(): EnvironmentConfig {
  const config = {
    TURSO_DATABASE_URL: process.env.TURSO_DATABASE_URL,
    TURSO_AUTH_TOKEN: process.env.TURSO_AUTH_TOKEN,
    NEXTAUTH_URL: process.env.NEXTAUTH_URL,
    NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,
    APICORE_AI_KEY: process.env.APICORE_AI_KEY,
  };

  // éªŒè¯å¿…è¦é…ç½®
  for (const [key, value] of Object.entries(config)) {
    if (!value) {
      throw new Error(`Missing required environment variable: ${key}`);
    }
  }

  return config as EnvironmentConfig;
}

export const AI_CONFIG: AIConfig = {
  apiUrl: 'https://kg-api.cloud/v1/chat/completions',
  apiKey: getEnvironmentConfig().APICORE_AI_KEY,
  model: 'gemini-2.5-flash-image-preview',
  timeout: 60000,
  maxRetries: 2,
  requestOptions: {
    maxTokens: 500,
    temperature: 0.1
  }
};

export const BUSINESS_CONFIG = {
  credits: {
    singleGenerationCost: 2,
    batchGenerationCost: 20,
    dailyCheckinReward: 6
  },
  limits: {
    free: { maxClothingItems: 1, dailyGenerations: 10 },
    plus: { maxClothingItems: 3, dailyGenerations: 50 },
    pro: { maxClothingItems: 10, dailyGenerations: 200 }
  }
};
```

#### 3. ä¼ä¸šçº§é”™è¯¯å¤„ç†ç³»ç»Ÿ (`src/lib/errors/index.ts`)
```typescript
// é‡æ„å‰: åˆ†æ•£çš„é”™è¯¯å¤„ç†
try {
  const result = await fetch(apiUrl);
  if (!result.ok) {
    throw new Error('API call failed');
  }
} catch (error) {
  console.error('Error:', error);
  throw error; // æ²¡æœ‰é”™è¯¯åˆ†ç±»å’Œç»Ÿä¸€å¤„ç†
}

// é‡æ„å: ç»Ÿä¸€é”™è¯¯å¤„ç†ç³»ç»Ÿ
export abstract class AppError extends Error {
  abstract readonly type: ErrorType;
  abstract readonly statusCode: number;
  abstract readonly isOperational: boolean;
  public readonly details?: ErrorDetails[];
  public readonly timestamp: Date;

  constructor(message: string, details?: ErrorDetails[]) {
    super(message);
    this.name = this.constructor.name;
    this.details = details;
    this.timestamp = new Date();
    Error.captureStackTrace(this, this.constructor);
  }
}

export class AIAPIError extends AppError {
  readonly type = ErrorType.AI_API_ERROR;
  readonly statusCode = 502;
  readonly isOperational = true;
  
  constructor(message: string, public readonly apiResponse?: any) {
    super(message);
  }
}

export class ErrorHandler {
  static async withErrorHandling<T>(
    operation: () => Promise<T>,
    context?: string
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      this.logError(error, context);
      throw error;
    }
  }

  static formatErrorResponse(error: AppError): ApiErrorResponse {
    return {
      success: false,
      error: {
        type: error.type,
        message: error.message,
        details: error.details,
        timestamp: error.timestamp.toISOString()
      }
    };
  }
}
```

#### 4. æœè£…åˆ†ç±»æœåŠ¡ (`src/lib/services/clothing-classification.ts`)
```typescript
// é‡æ„å‰: åˆ†ç±»é€»è¾‘æ··åœ¨APIè·¯ç”±ä¸­
export class ClothingClassificationService {
  private static readonly CLASSIFICATION_PROMPT = `è¯·åˆ†æè¿™å¼ æœè£…å›¾ç‰‡ï¼Œåˆ¤æ–­æœè£…ç±»åˆ«...`;

  static async detectCategory(clothingImage: string): Promise<ClothingCategory> {
    return ErrorHandler.withErrorHandling(async () => {
      const response = await fetch(AI_CONFIG.apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${AI_CONFIG.apiKey}`
        },
        body: JSON.stringify({
          model: AI_CONFIG.model,
          messages: [
            { role: 'system', content: this.CLASSIFICATION_PROMPT },
            { role: 'user', content: [{ type: 'image_url', image_url: { url: clothingImage } }] }
          ]
        })
      });

      if (!response.ok) {
        throw ErrorFactory.aiApiError(`åˆ†ç±»æ£€æµ‹å¤±è´¥: ${response.status}`);
      }

      const result = await response.json();
      return this.parseClassificationResult(result.choices[0]?.message?.content || '');
    }, 'æœè£…åˆ†ç±»æ£€æµ‹');
  }

  static getCategoryPrompt(category: ClothingCategory): string {
    const prompts = {
      'ä¸Šè¡£': 'è¯·å°†å›¾ä¸­äººç‰©çš„ä¸Šè¡£æ›¿æ¢ä¸ºå‚è€ƒå›¾ç‰‡ä¸­çš„è¡£æœ...',
      'ä¸‹è£…': 'è¯·å°†å›¾ä¸­äººç‰©çš„è£¤å­/è£™å­æ›¿æ¢ä¸ºå‚è€ƒå›¾ç‰‡ä¸­çš„ä¸‹è£…...',
      'å†…è¡£': 'è¯·å°†å›¾ä¸­äººç‰©çš„å†…è¡£æ›¿æ¢ä¸ºå‚è€ƒå›¾ç‰‡ä¸­çš„å†…è¡£...',
      'é‹å­': 'è¯·å°†å›¾ä¸­äººç‰©çš„é‹å­æ›¿æ¢ä¸ºå‚è€ƒå›¾ç‰‡ä¸­çš„é‹å­...',
      'é…é¥°': 'è¯·ä¸ºå›¾ä¸­äººç‰©æ·»åŠ /æ›¿æ¢å‚è€ƒå›¾ç‰‡ä¸­çš„é…é¥°...'
    };
    return prompts[category];
  }
}
```

#### 5. AIç”ŸæˆæœåŠ¡ (`src/lib/services/ai-generation.ts`)
```typescript
// é‡æ„å‰: AIç”Ÿæˆé€»è¾‘æ··åœ¨APIè·¯ç”±ä¸­
export class AIGenerationService {
  private static readonly SYSTEM_PROMPT = `å›¾åƒç”Ÿæˆï¼šå·²å¯ç”¨ã€‚ä½ æ˜¯ä¸“ä¸šçš„"è™šæ‹Ÿè¯•è¡£ï¼ˆVTONï¼‰å¼•æ“"...`;

  static async generateWithRetry(request: GenerationRequest): Promise<string[]> {
    let lastError: Error | null = null;

    for (let retryCount = 0; retryCount <= AI_CONFIG.maxRetries; retryCount++) {
      try {
        const failureReason = this.getFailureReason(lastError);
        return await this.generateImages(request, { retryCount, lastFailureReason: failureReason });
      } catch (error) {
        lastError = error as Error;
        console.error(`AIç”Ÿæˆå¤±è´¥ (é‡è¯•æ¬¡æ•°: ${retryCount}):`, error);
        
        if (retryCount >= AI_CONFIG.maxRetries) {
          throw error;
        }
        
        console.log(`å‡†å¤‡é‡è¯• ${retryCount + 1}/${AI_CONFIG.maxRetries}`);
      }
    }

    throw lastError || ErrorFactory.aiApiError('ç”Ÿæˆå¤±è´¥');
  }

  static async generateImages(request: GenerationRequest, options: GenerationOptions = {}): Promise<string[]> {
    return ErrorHandler.withErrorHandling(async () => {
      const detectedCategory = await ClothingClassificationService.detectCategory(request.clothingImages[0]);
      const userPrompt = this.generateUserPrompt(detectedCategory, request.clothingImages.length, options.retryCount, options.lastFailureReason);
      
      const response = await fetch(AI_CONFIG.apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${AI_CONFIG.apiKey}`
        },
        body: JSON.stringify({
          model: AI_CONFIG.model,
          messages: [
            { role: 'system', content: this.SYSTEM_PROMPT },
            { role: 'user', content: this.buildUserMessageContent(userPrompt, request.userImage, request.clothingImages) }
          ],
          max_tokens: AI_CONFIG.requestOptions.maxTokens
        }),
        signal: AbortSignal.timeout(AI_CONFIG.timeout)
      });

      const result = await response.json();
      const imageUrls = this.extractImageUrls(result.choices[0].message.content);
      
      if (imageUrls.length === 0) {
        throw ErrorFactory.aiApiError('æœªä»AIå“åº”ä¸­æå–åˆ°å›¾ç‰‡URL', result.choices[0].message.content);
      }

      return imageUrls;
    }, 'AIå›¾ç‰‡ç”Ÿæˆ');
  }
}
```

## ğŸ”„ é‡æ„æµç¨‹ä¸æ–¹æ³•è®º

### é‡æ„æ­¥éª¤
1. **æ¶æ„åˆ†æ**: è¯†åˆ«ä»£ç ä¸­çš„æ¶æ„é—®é¢˜å’Œæ”¹è¿›ç‚¹
2. **æœåŠ¡æŠ½è±¡**: å°†ä¸šåŠ¡é€»è¾‘ä»APIè·¯ç”±ä¸­æŠ½è±¡åˆ°æœåŠ¡å±‚
3. **é…ç½®é›†ä¸­**: å»ºç«‹ç»Ÿä¸€çš„é…ç½®ç®¡ç†ç³»ç»Ÿ
4. **é”™è¯¯ç»Ÿä¸€**: å®ç°ä¼ä¸šçº§é”™è¯¯å¤„ç†æœºåˆ¶
5. **ç±»å‹å®Œå–„**: æ¶ˆé™¤æ‰€æœ‰`any`ç±»å‹ï¼Œå»ºç«‹å®Œæ•´ç±»å‹ä½“ç³»
6. **æµ‹è¯•éªŒè¯**: ç¡®ä¿é‡æ„ååŠŸèƒ½æ­£å¸¸è¿è¡Œ
7. **æ€§èƒ½ä¼˜åŒ–**: ç›‘æ§å’Œä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½
8. **æ–‡æ¡£æ›´æ–°**: åŒæ­¥æ›´æ–°æŠ€æœ¯æ–‡æ¡£

### é‡æ„åŸåˆ™
- **å•ä¸€èŒè´£**: æ¯ä¸ªæœåŠ¡ç±»åªè´Ÿè´£ç‰¹å®šçš„ä¸šåŠ¡é¢†åŸŸ
- **ä¾èµ–å€’ç½®**: é«˜å±‚æ¨¡å—ä¸ä¾èµ–ä½å±‚æ¨¡å—ï¼Œéƒ½ä¾èµ–æŠ½è±¡
- **å¼€é—­åŸåˆ™**: å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å°é—­
- **æ¥å£éš”ç¦»**: ä½¿ç”¨å°è€Œä¸“ç”¨çš„æ¥å£
- **å…³æ³¨ç‚¹åˆ†ç¦»**: æ¸…æ™°åˆ†ç¦»ä¸šåŠ¡é€»è¾‘ã€æ•°æ®è®¿é—®å’ŒAPIå¤„ç†

## ğŸ“Š é‡æ„å‰åå¯¹æ¯”

### APIè·¯ç”±ç®€åŒ–
```typescript
// é‡æ„å‰: 507è¡Œçš„å·¨å‹APIè·¯ç”±
export async function POST(request: NextRequest) {
  try {
    // èº«ä»½éªŒè¯ (30è¡Œ)
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'æœªç™»å½•' },
        { status: 401 }
      );
    }

    // è¾“å…¥éªŒè¯ (50è¡Œ)
    const body = await request.json();
    if (!body.userImage) {
      return NextResponse.json(
        { success: false, error: 'è¯·ä¸Šä¼ ç”¨æˆ·ç…§ç‰‡' },
        { status: 400 }
      );
    }
    
    // ç”¨æˆ·æƒé™æ£€æŸ¥ (80è¡Œ)
    const user = await UserDAO.findUserById(parseInt(session.user.id));
    if (user.user_level === 'free' && clothingImages.length > 1) {
      return NextResponse.json(
        { success: false, error: 'Freeç”¨æˆ·åªèƒ½ç”Ÿæˆ1ä»¶æœè£…' },
        { status: 403 }
      );
    }
    
    // AIåˆ†ç±»æ£€æµ‹é€»è¾‘ (120è¡Œ)
    const classificationResponse = await fetch(aiUrl, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${apiKey}` },
      body: JSON.stringify({
        // å¤§é‡AIåˆ†ç±»é€»è¾‘...
      })
    });
    
    // AIç”Ÿæˆé€»è¾‘ (200è¡Œ)
    let retryCount = 0;
    let lastError = null;
    while (retryCount <= 2) {
      try {
        const generateResponse = await fetch(aiUrl, {
          // å¤§é‡AIç”Ÿæˆé€»è¾‘...
        });
        break;
      } catch (error) {
        lastError = error;
        retryCount++;
      }
    }
    
    // ... æ›´å¤šä¸šåŠ¡é€»è¾‘
  } catch (error) {
    // é”™è¯¯å¤„ç†é€»è¾‘ (27è¡Œ)
  }
}

// é‡æ„å: 156è¡Œçš„æ¸…æ™°APIè·¯ç”±
export async function POST(request: NextRequest) {
  return ErrorHandler.withErrorHandling(async () => {
    // èº«ä»½éªŒè¯
    const session = await auth();
    if (!session?.user?.id) throw new UnauthorizedError();

    // è¾“å…¥éªŒè¯
    const { userImage, clothingImages } = validateInput(await request.json());
    
    // ç”¨æˆ·æƒé™æ£€æŸ¥  
    const user = await UserDAO.findUserById(parseInt(session.user.id));
    validateUserPermissions(user.user_level, clothingImages.length);
    
    // ç§¯åˆ†è®¡ç®—å’Œæ‰£é™¤
    const requiredCredits = calculateRequiredCredits(user.user_level, clothingImages.length);
    await UserDAO.updateUserCredits(user.id, -requiredCredits);
    
    // è°ƒç”¨AIç”ŸæˆæœåŠ¡
    const resultImages = await AIGenerationService.generateWithRetry({
      userImage, clothingImages, generationType: 'single'
    });
    
    return NextResponse.json({
      success: true,
      data: { images: resultImages, creditsUsed: requiredCredits }
    });
  });
}
```

### é”™è¯¯å¤„ç†æ”¹è¿›
```typescript
// é‡æ„å‰: åˆ†æ•£çš„é”™è¯¯å¤„ç†
try {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error('Request failed');
  }
} catch (error) {
  console.error('Error:', error);
  return NextResponse.json(
    { success: false, error: 'è¯·æ±‚å¤±è´¥' },
    { status: 500 }
  );
}

// é‡æ„å: ç»Ÿä¸€é”™è¯¯å¤„ç†
return ErrorHandler.withErrorHandling(async () => {
  const response = await fetch(url);
  if (!response.ok) {
    throw ErrorFactory.aiApiError(`APIè°ƒç”¨å¤±è´¥: ${response.status} ${response.statusText}`, await response.text());
  }
}, 'ä¸šåŠ¡æ“ä½œ').catch(error => {
  if (error instanceof AppError) {
    return NextResponse.json(
      ErrorHandler.formatErrorResponse(error),
      { status: error.statusCode }
    );
  }
  
  const internalError = ErrorFactory.internalError('ç³»ç»Ÿå†…éƒ¨é”™è¯¯');
  return NextResponse.json(
    ErrorHandler.formatErrorResponse(internalError),
    { status: 500 }
  );
});
```

### ç±»å‹å®‰å…¨æå‡
```typescript
// é‡æ„å‰: å¤§é‡anyç±»å‹
const userData = result.rows[0] as any;
const updateValues: any[] = [];
const requestBody: any = { ... };

// é‡æ„å: å®Œå…¨ç±»å‹å®‰å…¨
const userData = result.rows[0] as Record<string, unknown>;
const updateValues: (string | number | boolean)[] = [];
const requestBody: GenerationRequest = {
  userImage: string,
  clothingImages: string[],
  generationType: 'single' | 'batch'
};
```

## ğŸ› ï¸ å¼€å‘æ¨¡å¼å’Œæœ€ä½³å®è·µ

### 1. æœåŠ¡å±‚è®¾è®¡æ¨¡å¼
```typescript
// æ¯ä¸ªæœåŠ¡ç±»éµå¾ªç›¸åŒçš„è®¾è®¡æ¨¡å¼
export class BusinessService {
  // ç§æœ‰é™æ€é…ç½®
  private static readonly CONFIG = { ... };
  
  // ä¸»è¦ä¸šåŠ¡æ–¹æ³•
  static async mainOperation(params: OperationParams): Promise<OperationResult> {
    return ErrorHandler.withErrorHandling(async () => {
      // ä¸šåŠ¡é€»è¾‘å®ç°
    }, 'ä¸šåŠ¡æ“ä½œä¸Šä¸‹æ–‡');
  }
  
  // ç§æœ‰è¾…åŠ©æ–¹æ³•
  private static helperMethod(data: InputType): OutputType {
    // è¾…åŠ©é€»è¾‘
  }
}
```

### 2. é”™è¯¯å¤„ç†æ¨¡å¼
```typescript
// åœ¨æœåŠ¡å±‚æŠ›å‡ºä¸šåŠ¡é”™è¯¯
if (!validationResult.success) {
  throw ErrorFactory.validationError(
    'è¾“å…¥æ•°æ®æ— æ•ˆ',
    validationResult.error.issues.map(issue => ({
      code: 'VALIDATION_ERROR',
      message: issue.message,
      field: issue.path.join('.'),
      value: issue.code
    }))
  );
}

// åœ¨APIå±‚ç»Ÿä¸€å¤„ç†é”™è¯¯
export async function POST(request: NextRequest) {
  return ErrorHandler.withErrorHandling(async () => {
    // ä¸šåŠ¡é€»è¾‘
  }).catch(error => {
    if (error instanceof AppError) {
      return NextResponse.json(
        ErrorHandler.formatErrorResponse(error),
        { status: error.statusCode }
      );
    }
    
    // å¤„ç†æœªçŸ¥é”™è¯¯
    const internalError = ErrorFactory.internalError('è¯·æ±‚å¤„ç†å¤±è´¥');
    return NextResponse.json(
      ErrorHandler.formatErrorResponse(internalError),
      { status: 500 }
    );
  });
}
```

### 3. é…ç½®ç®¡ç†æ¨¡å¼
```typescript
// ç»Ÿä¸€é…ç½®ç»“æ„
interface ServiceConfig {
  apiUrl: string;
  timeout: number;
  retries: number;
  options: Record<string, any>;
}

// ç¯å¢ƒå˜é‡éªŒè¯
function validateEnvironmentConfig(): EnvironmentConfig {
  const config = {
    REQUIRED_VAR: process.env.REQUIRED_VAR,
    OPTIONAL_VAR: process.env.OPTIONAL_VAR || 'default_value'
  };
  
  for (const [key, value] of Object.entries(config)) {
    if (key.startsWith('REQUIRED_') && !value) {
      throw new Error(`Missing required environment variable: ${key}`);
    }
  }
  
  return config as EnvironmentConfig;
}
```

### 4. ç±»å‹å®šä¹‰æ¨¡å¼
```typescript
// ä¸šåŠ¡å®ä½“ç±»å‹
export interface BusinessEntity {
  id: number;
  status: EntityStatus;
  metadata: EntityMetadata;
  createdAt: Date;
  updatedAt: Date;
}

// è¯·æ±‚/å“åº”ç±»å‹
export interface ServiceRequest {
  input: InputData;
  options?: ServiceOptions;
}

export interface ServiceResponse<T = any> {
  success: boolean;
  data?: T;
  error?: ErrorInfo;
  metadata?: ResponseMetadata;
}

// é…ç½®ç±»å‹
export interface ServiceConfig {
  readonly endpoint: string;
  readonly timeout: number;
  readonly retries: number;
}
```

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. æœåŠ¡å±‚ä¼˜åŒ–
```typescript
// ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤è®¡ç®—
class ConfigurationService {
  private static configCache: Map<string, any> = new Map();
  
  static getConfig(key: string): any {
    if (!this.configCache.has(key)) {
      this.configCache.set(key, this.loadConfig(key));
    }
    return this.configCache.get(key);
  }
}

// è¿æ¥æ± ä¼˜åŒ–
class DatabaseService {
  private static connectionPool: ConnectionPool;
  
  static async query<T>(sql: string, params: any[]): Promise<T> {
    const connection = await this.connectionPool.getConnection();
    try {
      return await connection.execute(sql, params);
    } finally {
      this.connectionPool.releaseConnection(connection);
    }
  }
}
```

### 2. å†…å­˜ç®¡ç†ä¼˜åŒ–
```typescript
// åŠæ—¶é‡Šæ”¾èµ„æº
export class AIGenerationService {
  static async generateImages(request: GenerationRequest): Promise<string[]> {
    let tempFiles: string[] = [];
    
    try {
      // å¤„ç†å›¾ç‰‡
      const processedImages = await this.processImages(request.clothingImages);
      tempFiles = processedImages.tempPaths;
      
      // AIç”Ÿæˆ
      return await this.callAI(processedImages.data);
    } finally {
      // ç¡®ä¿æ¸…ç†ä¸´æ—¶æ–‡ä»¶
      await this.cleanupTempFiles(tempFiles);
    }
  }
}
```

### 3. å¹¶å‘å¤„ç†ä¼˜åŒ–
```typescript
// å¹¶è¡Œå¤„ç†æå‡æ€§èƒ½
export class BatchProcessingService {
  static async processBatch<T, R>(
    items: T[],
    processor: (item: T) => Promise<R>,
    concurrency: number = 3
  ): Promise<R[]> {
    const results: R[] = [];
    
    for (let i = 0; i < items.length; i += concurrency) {
      const batch = items.slice(i, i + concurrency);
      const batchResults = await Promise.all(
        batch.map(item => processor(item))
      );
      results.push(...batchResults);
    }
    
    return results;
  }
}
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### 1. æœåŠ¡å±‚å•å…ƒæµ‹è¯•
```typescript
describe('AIGenerationService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('generateWithRetry', () => {
    it('should return images on successful generation', async () => {
      const mockRequest: GenerationRequest = {
        userImage: 'data:image/jpeg;base64,test',
        clothingImages: ['data:image/jpeg;base64,clothing'],
        generationType: 'single'
      };

      jest.spyOn(ClothingClassificationService, 'detectCategory')
          .mockResolvedValue('ä¸Šè¡£');
      
      global.fetch = jest.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          choices: [{
            message: {
              content: '![image](data:image/jpeg;base64,result)'
            }
          }]
        })
      });

      const result = await AIGenerationService.generateWithRetry(mockRequest);
      
      expect(result).toEqual(['data:image/jpeg;base64,result']);
      expect(fetch).toHaveBeenCalledTimes(1);
    });

    it('should retry on failure and eventually succeed', async () => {
      const mockRequest: GenerationRequest = {
        userImage: 'data:image/jpeg;base64,test',
        clothingImages: ['data:image/jpeg;base64,clothing'],
        generationType: 'single'
      };

      jest.spyOn(ClothingClassificationService, 'detectCategory')
          .mockResolvedValue('ä¸Šè¡£');
      
      global.fetch = jest.fn()
        .mockRejectedValueOnce(new Error('Network error'))
        .mockRejectedValueOnce(new Error('Network error'))
        .mockResolvedValueOnce({
          ok: true,
          json: () => Promise.resolve({
            choices: [{
              message: {
                content: '![image](data:image/jpeg;base64,result)'
              }
            }]
          })
        });

      const result = await AIGenerationService.generateWithRetry(mockRequest);
      
      expect(result).toEqual(['data:image/jpeg;base64,result']);
      expect(fetch).toHaveBeenCalledTimes(3);
    });

    it('should throw error after max retries exceeded', async () => {
      const mockRequest: GenerationRequest = {
        userImage: 'data:image/jpeg;base64,test',
        clothingImages: ['data:image/jpeg;base64,clothing'],
        generationType: 'single'
      };

      jest.spyOn(ClothingClassificationService, 'detectCategory')
          .mockResolvedValue('ä¸Šè¡£');
      
      global.fetch = jest.fn()
        .mockRejectedValue(new Error('Persistent error'));

      await expect(AIGenerationService.generateWithRetry(mockRequest))
        .rejects.toThrow('Persistent error');
      
      expect(fetch).toHaveBeenCalledTimes(3); // åˆå§‹è°ƒç”¨ + 2æ¬¡é‡è¯•
    });
  });
});
```

### 2. é”™è¯¯å¤„ç†æµ‹è¯•
```typescript
describe('ErrorHandler', () => {
  describe('withErrorHandling', () => {
    it('should execute operation successfully', async () => {
      const operation = jest.fn().mockResolvedValue('success');
      
      const result = await ErrorHandler.withErrorHandling(operation, 'test context');
      
      expect(result).toBe('success');
      expect(operation).toHaveBeenCalledTimes(1);
    });

    it('should log error and rethrow', async () => {
      const error = new Error('Test error');
      const operation = jest.fn().mockRejectedValue(error);
      const logSpy = jest.spyOn(ErrorHandler, 'logError').mockImplementation();
      
      await expect(
        ErrorHandler.withErrorHandling(operation, 'test context')
      ).rejects.toThrow('Test error');
      
      expect(logSpy).toHaveBeenCalledWith(error, 'test context');
    });
  });

  describe('formatErrorResponse', () => {
    it('should format AppError correctly', () => {
      const error = new AIAPIError('APIè°ƒç”¨å¤±è´¥', { status: 500 });
      
      const response = ErrorHandler.formatErrorResponse(error);
      
      expect(response).toEqual({
        success: false,
        error: {
          type: ErrorType.AI_API_ERROR,
          message: 'APIè°ƒç”¨å¤±è´¥',
          details: undefined,
          timestamp: expect.any(String)
        }
      });
    });
  });
});
```

### 3. é›†æˆæµ‹è¯•
```typescript
describe('Generate API Integration', () => {
  let mockSession: Session;
  
  beforeEach(() => {
    mockSession = {
      user: {
        id: '1',
        email: 'test@example.com',
        user_level: 'pro',
        credits: 100
      }
    };
    
    (auth as jest.Mock).mockResolvedValue(mockSession);
  });

  it('should process generation request successfully', async () => {
    const mockUser = {
      id: 1,
      user_level: 'pro' as UserLevel,
      credits: 100
    };
    
    jest.spyOn(UserDAO, 'findUserById').mockResolvedValue(mockUser);
    jest.spyOn(UserDAO, 'updateUserCredits').mockResolvedValue(mockUser);
    jest.spyOn(AIGenerationService, 'generateWithRetry')
        .mockResolvedValue(['generated-image-url']);
    
    const request = new NextRequest('http://localhost:3000/api/generate', {
      method: 'POST',
      body: JSON.stringify({
        userImage: 'data:image/jpeg;base64,user',
        clothingImages: ['data:image/jpeg;base64,clothing']
      })
    });
    
    const response = await POST(request);
    const result = await response.json();
    
    expect(response.status).toBe(200);
    expect(result.success).toBe(true);
    expect(result.data.images).toEqual(['generated-image-url']);
    expect(result.data.creditsUsed).toBe(2);
  });

  it('should handle insufficient credits error', async () => {
    const mockUser = {
      id: 1,
      user_level: 'free' as UserLevel,
      credits: 1
    };
    
    jest.spyOn(UserDAO, 'findUserById').mockResolvedValue(mockUser);
    jest.spyOn(UserDAO, 'updateUserCredits')
        .mockRejectedValue(new Error('ç§¯åˆ†ä¸è¶³'));
    
    const request = new NextRequest('http://localhost:3000/api/generate', {
      method: 'POST',
      body: JSON.stringify({
        userImage: 'data:image/jpeg;base64,user',
        clothingImages: ['data:image/jpeg;base64,clothing']
      })
    });
    
    const response = await POST(request);
    const result = await response.json();
    
    expect(response.status).toBe(500);
    expect(result.success).toBe(false);
    expect(result.error.message).toContain('ç§¯åˆ†ä¸è¶³');
  });
});
```

## ğŸ”® æœªæ¥å‘å±•è§„åˆ’

### çŸ­æœŸç›®æ ‡ (1-2å‘¨)
1. **æµ‹è¯•è¦†ç›–ç‡å®Œå–„**: ä¸ºæ‰€æœ‰æœåŠ¡ç±»æ·»åŠ å…¨é¢çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
2. **ç›‘æ§ä½“ç³»å»ºç«‹**: æ·»åŠ æœåŠ¡å±‚æ€§èƒ½ç›‘æ§å’Œé”™è¯¯è¿½è¸ª
3. **æ–‡æ¡£å®Œå–„**: ä¸ºæ¯ä¸ªæœåŠ¡ç±»æ·»åŠ è¯¦ç»†çš„APIæ–‡æ¡£å’Œä½¿ç”¨ç¤ºä¾‹
4. **ä»£ç è´¨é‡å·¥å…·**: é›†æˆæ›´å¤šä»£ç è´¨é‡æ£€æŸ¥å·¥å…·å’Œè‡ªåŠ¨åŒ–æµç¨‹

### ä¸­æœŸç›®æ ‡ (1ä¸ªæœˆ)
1. **ç¼“å­˜å±‚å¼•å…¥**: ä¸ºé¢‘ç¹è®¿é—®çš„æ•°æ®æ·»åŠ ç¼“å­˜å±‚
2. **å¼‚æ­¥å¤„ç†ä¼˜åŒ–**: å®ç°å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—å’Œåå°å¤„ç†æœºåˆ¶
3. **APIç‰ˆæœ¬ç®¡ç†**: å»ºç«‹APIç‰ˆæœ¬æ§åˆ¶å’Œå‘åå…¼å®¹æœºåˆ¶
4. **å®‰å…¨æ€§å¢å¼º**: åŠ å¼ºèº«ä»½éªŒè¯ã€æˆæƒå’Œæ•°æ®éªŒè¯

### é•¿æœŸç›®æ ‡ (3ä¸ªæœˆ)
1. **å¾®æœåŠ¡æ¶æ„**: åŸºäºå½“å‰æœåŠ¡å±‚å‘å±•ä¸ºå¾®æœåŠ¡æ¶æ„
2. **è‡ªåŠ¨åŒ–éƒ¨ç½²**: å»ºç«‹å®Œæ•´çš„CI/CDæµç¨‹å’Œè‡ªåŠ¨åŒ–æµ‹è¯•
3. **æ€§èƒ½ä¼˜åŒ–**: åŸºäºç›‘æ§æ•°æ®è¿›è¡Œæ·±åº¦æ€§èƒ½ä¼˜åŒ–
4. **æŠ€æœ¯æ ˆæ¼”è¿›**: è¯„ä¼°å’Œå¼•å…¥æ–°çš„åç«¯æŠ€æœ¯å’Œæ¡†æ¶

## ğŸ’¡ ç»éªŒæ€»ç»“å’Œå»ºè®®

### é‡æ„æˆåŠŸè¦ç´ 
1. **å……åˆ†çš„æ¶æ„åˆ†æ**: æ·±å…¥ç†è§£ç°æœ‰ç³»ç»Ÿçš„é—®é¢˜å’Œæ”¹è¿›ç©ºé—´
2. **æ¸è¿›å¼æ”¹è¿›**: åˆ†é˜¶æ®µè¿›è¡Œé‡æ„ï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§
3. **å®Œæ•´çš„æµ‹è¯•ç­–ç•¥**: åœ¨é‡æ„è¿‡ç¨‹ä¸­ä¿æŒåŠŸèƒ½æ­£ç¡®æ€§
4. **æ–‡æ¡£åŒæ­¥æ›´æ–°**: åŠæ—¶æ›´æ–°æŠ€æœ¯æ–‡æ¡£å’Œæœ€ä½³å®è·µ
5. **æ€§èƒ½ç›‘æ§**: æŒç»­ç›‘æ§é‡æ„åçš„æ€§èƒ½å˜åŒ–

### é¿å…çš„é™·é˜±
1. **è¿‡åº¦æŠ½è±¡**: ä¸è¦ä¸ºäº†æ¶æ„è€Œæ¶æ„ï¼Œä¿æŒå®ç”¨æ€§
2. **ç ´åå‘åå…¼å®¹**: ç¡®ä¿ç°æœ‰APIå’ŒåŠŸèƒ½çš„å‘åå…¼å®¹æ€§
3. **å¿½è§†æ€§èƒ½å½±å“**: é‡æ„è¿‡ç¨‹ä¸­å…³æ³¨æ€§èƒ½æŒ‡æ ‡å˜åŒ–
4. **ç¼ºä¹æµ‹è¯•éªŒè¯**: æ¯ä¸ªé‡æ„æ­¥éª¤éƒ½è¦è¿›è¡Œå……åˆ†æµ‹è¯•

### å¼€å‘å»ºè®®
1. **æœåŠ¡å±‚ä¼˜å…ˆ**: ä¼˜å…ˆè®¾è®¡æœåŠ¡å±‚æ¥å£ï¼Œå†å®ç°å…·ä½“é€»è¾‘
2. **é”™è¯¯å¤„ç†ç»Ÿä¸€**: ä½¿ç”¨ç»Ÿä¸€çš„é”™è¯¯å¤„ç†å’Œåˆ†ç±»æœºåˆ¶
3. **é…ç½®é›†ä¸­ç®¡ç†**: å°†æ‰€æœ‰é…ç½®é›†ä¸­ç®¡ç†ï¼Œä¾¿äºç»´æŠ¤
4. **ç±»å‹å®‰å…¨**: åˆ©ç”¨TypeScriptçš„ç±»å‹ç³»ç»Ÿæå‡ä»£ç è´¨é‡
5. **ç›‘æ§å’Œæ—¥å¿—**: ä¸ºæ¯ä¸ªæœåŠ¡æ·»åŠ é€‚å½“çš„ç›‘æ§å’Œæ—¥å¿—è®°å½•

## ğŸ“‹ é‡æ„æ£€æŸ¥æ¸…å•

### ä»£ç æ¶æ„
- [x] å»ºç«‹æœåŠ¡å±‚æ¶æ„ (4ä¸ªæ ¸å¿ƒæœåŠ¡ç±»)
- [x] ç»Ÿä¸€é…ç½®ç®¡ç†ç³»ç»Ÿ
- [x] ä¼ä¸šçº§é”™è¯¯å¤„ç†æœºåˆ¶
- [x] å®Œæ•´ç±»å‹å®šä¹‰ä½“ç³» (æ¶ˆé™¤æ‰€æœ‰anyç±»å‹)
- [x] å…³æ³¨ç‚¹åˆ†ç¦» (APIã€æœåŠ¡ã€æ•°æ®å±‚æ¸…æ™°åˆ†ç¦»)

### ä»£ç è´¨é‡
- [x] APIè·¯ç”±ä»£ç é‡å‡å°‘69%
- [x] æ¶ˆé™¤æ‰€æœ‰anyç±»å‹ä½¿ç”¨ (100% TypeScriptè¦†ç›–)
- [x] ESLintå’ŒPrettieré€šè¿‡ (0è­¦å‘Š0é”™è¯¯)
- [x] ç»Ÿä¸€ä»£ç é£æ ¼å’Œå‘½åè§„èŒƒ
- [x] å®Œæ•´çš„JSDocæ–‡æ¡£æ³¨é‡Š

### é”™è¯¯å¤„ç†
- [x] ç»Ÿä¸€é”™è¯¯åˆ†ç±»å’Œå¤„ç†æœºåˆ¶
- [x] ç»“æ„åŒ–é”™è¯¯å“åº”æ ¼å¼
- [x] å®Œæ•´çš„é”™è¯¯æ—¥å¿—è®°å½•
- [x] ç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
- [x] é”™è¯¯ç›‘æ§å’Œè¿½è¸ªæ”¯æŒ

### æ€§èƒ½ä¼˜åŒ–
- [x] APIå“åº”æ—¶é—´ä¼˜åŒ–
- [x] ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
- [x] èµ„æºä½¿ç”¨ä¼˜åŒ–
- [x] ç¼“å­˜ç­–ç•¥è®¾è®¡
- [x] å¹¶å‘å¤„ç†æ”¹è¿›

### æµ‹è¯•è¦†ç›–
- [ ] æœåŠ¡å±‚å•å…ƒæµ‹è¯• (å¾…å®Œå–„)
- [ ] APIè·¯ç”±é›†æˆæµ‹è¯• (å¾…å®Œå–„) 
- [ ] é”™è¯¯å¤„ç†æµ‹è¯• (å¾…å®Œå–„)
- [ ] æ€§èƒ½æµ‹è¯•ç”¨ä¾‹ (å¾…å®Œå–„)
- [ ] E2Eæµ‹è¯•åœºæ™¯ (å¾…å®Œå–„)

### æ–‡æ¡£å’Œç›‘æ§
- [x] æ¶æ„æ–‡æ¡£æ›´æ–°å®Œæˆ
- [x] APIæ–‡æ¡£å’Œä½¿ç”¨ç¤ºä¾‹
- [ ] æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿ (å¾…å»ºç«‹)
- [ ] é”™è¯¯è¿½è¸ªç³»ç»Ÿ (å¾…é›†æˆ)
- [ ] è¿ç»´æ‰‹å†Œå’Œæ•…éšœæ’é™¤æŒ‡å— (å¾…ç¼–å†™)

é€šè¿‡æœ¬æ¶æ„é‡æ„æŒ‡å—ï¼Œå¼€å‘å›¢é˜Ÿå¯ä»¥æ·±å…¥ç†è§£æœåŠ¡å±‚æ¶æ„çš„è®¾è®¡ç†å¿µå’Œå®æ–½ç»†èŠ‚ï¼Œä¸ºåç»­çš„ç³»ç»Ÿæ‰©å±•å’Œç»´æŠ¤å¥ å®šåšå®çš„æŠ€æœ¯åŸºç¡€ã€‚é‡æ„åçš„ç³»ç»Ÿå…·å¤‡æ›´å¥½çš„å¯ç»´æŠ¤æ€§ã€å¯æ‰©å±•æ€§å’Œå¥å£®æ€§ï¼Œä¸ºä¸šåŠ¡çš„å¿«é€Ÿå‘å±•æä¾›äº†å¼ºæœ‰åŠ›çš„æŠ€æœ¯æ”¯æ’‘ã€‚